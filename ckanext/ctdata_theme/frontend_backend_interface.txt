To request the data from the backend for any of the views, send a POST request with the following json body to the
/data/{dataset_id} endpoint:
{"view": "map"|"table"|"chart",
 "filters": [{"field": "field value", "values": ["option 1", "option 2]},
             ...]}
Even if you have a single value for filter you should enclose it in a list syntax.
"map" view isn't implemented yet, since I'm not sure in which form I should return the data.
It's possible to specify "all" as a filter value, the values would be properly aggreagted by the backend (the structure
of replies wouldn't be changed, only the values would be affected)

For the "table" view the reply would be (for example) (assuming there were selected several values for the 'town',
'grade' and 'measure type' dimensions):
{
    'multifield': 'grade',
    'years': ['2013'],
	'data': [
	    {'town': 'town1 name',
        'multifield': [
            {'value': 'Grade 3', 'data': [{'measure_type': 'number', 'data': [*list of values, one for every year*]},
                                          {'measure_type': 'percent', 'data': [...]}]},
            {'value': 'Grade 4', 'data': [{'measure_type': 'number', 'data': [...]},
                                          {'measure_type': 'percent', 'data': [...]}]}
        ]]},
	    {'town': 'town2 name',
        'multifield': [
            {'value': 'Grade 3', 'data': [{'measure_type': 'number', 'data': [*list of values, one for every year*]},
                                          {'measure_type': 'percent', 'data': [...]}]},
            {'value': 'Grade 4', 'data': [{'measure_type': 'number', 'data': [...]},
                                          {'measure_type': 'percent', 'data': [...]}]}
        ]]}
    ]
}

This can be easily translated into an html representation (pseudocode):
<table>
    <th>
        <td>Location</td>
        <td>global['multifield']</td>
        <td>Data Type</td>
        for year in data['years']
            <td>year</td>
    </th>
for town in data['data']:
    for mf in town['multifield']:
        for mt in mf['data']:
            <tr>
                <td>town['town']</td>
                <td>mf['value']</td>
                <td>mt['measuretype']</td>
                for value in mt['data']:
                    <td>value</td>
            </tr>
<table>


For the chart views (bar and line both), the reply would be:
{
    'years': ['2012', '2013'],
	'data': [
	    {'name': 'town1 name',
         'data': [*list of values, one for every year*]},
	    {'name': 'town2 name',
         'data': [*list of values, one for every year*]},
    ]
}

About building checkboxes for filters on the frontend: I can create an endpoint just like the one that's currently
implemented in the feature_bar_chart branch (/data/{resource_id}, "get_resource_data") or we can genrate the controls
in the visualization.html template itself, using jinja. The second approach seems better to me (since there's no need
to make additional http-queries and this way the presentation is better separated from the logic), but let me know if
there're any objections.

I generated the checkboxes in the visualization template, much better than
the old way. Also, a good reply for the map view is just the same as for
the reply for the chart views
